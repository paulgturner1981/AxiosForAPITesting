"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _MockServer_mockServer, _MockServer_createRoute, _MockServer_getMiddlewareList, _MockServer_addDb, _MockServer_getDb, _MockServer_updateRouteConfig;
Object.defineProperty(exports, "__esModule", { value: true });
exports.watcher = exports.axios = exports.chalk = exports.pathToRegexp = exports.spinner = exports.nanoid = exports.lodash = exports.express = exports.MockServer = void 0;
const axios_1 = __importDefault(require("axios"));
exports.axios = axios_1.default;
const chalk_1 = __importDefault(require("chalk"));
exports.chalk = chalk_1.default;
const watcher = __importStar(require("chokidar"));
exports.watcher = watcher;
const express_1 = __importDefault(require("express"));
exports.express = express_1.default;
const express_urlrewrite_1 = __importDefault(require("express-urlrewrite"));
const _ = __importStar(require("lodash"));
exports.lodash = _;
const nanoid = __importStar(require("nanoid"));
exports.nanoid = nanoid;
const ora_1 = __importDefault(require("ora"));
exports.spinner = ora_1.default;
const path_1 = __importDefault(require("path"));
const pathToRegexp = __importStar(require("path-to-regexp"));
exports.pathToRegexp = pathToRegexp;
const server_destroy_1 = __importDefault(require("server-destroy"));
const getters_setters_1 = require("./getters-setters");
const middlewares_1 = require("./middlewares");
const route_config_setters_1 = __importDefault(require("./route-config-setters"));
const utils_1 = require("./utils");
const validators_1 = require("./utils/validators");
// Helps to require .jsonc file using require("./path/db.jsonc")
require('jsonc-require');
class MockServer extends getters_setters_1.GettersSetters {
    constructor() {
        super(...arguments);
        _MockServer_createRoute.set(this, (routePath, routeConfig, router, validMiddlewares) => {
            if (this.routes.includes(routePath))
                return; // If routes are already added to resource then do nothing
            this.routes.push(routePath);
            this.getDb()[routePath] = routeConfig;
            this.initialDb[routePath] = _.cloneDeep(routeConfig);
            router.use(routePath, (0, middlewares_1.Initializer)(routePath, this));
            const middlewareList = __classPrivateFieldGet(this, _MockServer_getMiddlewareList, "f").call(this, routeConfig.middlewares, validMiddlewares, routeConfig.directUse);
            if (middlewareList.some((middleware) => middleware.name === 'serveStatic')) {
                middlewareList.forEach((middleware) => {
                    if (middleware.name === 'serveStatic')
                        return router.use(routePath, middleware);
                    return router.all(routePath, middleware);
                });
            }
            else {
                router.all(routePath, middlewareList);
            }
            // if the current route ends with config id param or if the routes list has already route that ends with config id param then return
            if (routePath.endsWith(`:${this.config.id}`) ||
                routePath.endsWith(`:${this.config.id}?`) ||
                this.routes.includes(routePath + `/:${this.config.id}`) ||
                this.routes.includes(routePath + `/:${this.config.id}?`))
                return;
            middlewareList.forEach((middleware) => {
                if (middleware.name === 'serveStatic')
                    return router.use(routePath + `/:${this.config.id || 'id'}`, middleware);
                return router === null || router === void 0 ? void 0 : router.all(routePath + `/:${this.config.id || 'id'}`, middleware);
            });
        });
        _MockServer_getMiddlewareList.set(this, (routeMiddlewares, globalMiddlewares = this.middlewares, directUse = false) => {
            const userMiddlewares = []
                .concat(routeMiddlewares || [])
                .filter(Boolean)
                .map((middleware) => (_.isString(middleware) ? globalMiddlewares[middleware] : middleware))
                .filter(_.isFunction);
            if (directUse)
                return userMiddlewares;
            return this.withHelperWrappers(userMiddlewares);
        });
        this.withHelperWrappers = (middlewares = []) => [
            middlewares_1.HelperMiddlewares._SetDelay,
            middlewares_1.HelperMiddlewares._Fetch,
            middlewares_1.HelperMiddlewares._SetStatusCode,
            middlewares_1.HelperMiddlewares._SetHeaders,
            middlewares_1.HelperMiddlewares._CrudOperation,
            ...[].concat(middlewares),
            middlewares_1.HelperMiddlewares._SetStatusCode,
            middlewares_1.HelperMiddlewares._SetHeaders,
            middlewares_1.HelperMiddlewares._SendResponse,
        ];
        this.pageNotFound = middlewares_1.PageNotFound;
        this.errorHandler = middlewares_1.ErrorHandler;
        _MockServer_addDb.set(this, (req, res, router) => {
            const validDb = (0, validators_1.getValidDb)(req.body, {
                dbMode: this.config.dbMode,
                injectors: this.injectors,
                mockServer: this._getServerDetails(),
                reverse: this.config.reverse,
                root: this.config.root,
            });
            const newDbEntries = Object.entries(validDb).filter(([routePath]) => !this.routes.includes(routePath));
            const response = {};
            newDbEntries.forEach(([routePath, routeConfig]) => {
                response[routePath] = routeConfig;
                __classPrivateFieldGet(this, _MockServer_createRoute, "f").call(this, routePath, routeConfig, router, this.middlewares);
            });
            res.send(response);
        });
        _MockServer_getDb.set(this, (req, res) => {
            const id = req.params.id;
            const findById = (id) => {
                const dbById = Object.entries(this.db).find(([, routeConfig]) => routeConfig.id === id);
                if (_.isEmpty(dbById))
                    return {};
                return { [dbById[0]]: dbById[1] };
            };
            const db = id ? findById(id) : this.db;
            const resultDb = req.query._clean ? (0, utils_1.getCleanDb)(db, this.config.dbMode) : db;
            res.send(resultDb);
        });
        _MockServer_updateRouteConfig.set(this, (req, res) => {
            const dbToUpdate = req.body;
            const response = {};
            const db = this.getDb();
            Object.entries(dbToUpdate).forEach(([routePath, routeConfig]) => {
                delete routeConfig.middlewares;
                if (db[routePath]) {
                    const fetchData = Object.assign(Object.assign({}, (db[routePath].fetchData || {})), (routeConfig.fetchData || {}));
                    (0, utils_1.replaceObj)(db[routePath], Object.assign(Object.assign(Object.assign({}, db[routePath]), routeConfig), (Object.keys(fetchData).length ? { fetchData } : {})));
                    response[routePath] = db[routePath];
                }
            });
            res.send(response);
        });
    }
    launchServer(db, { middlewares, injectors, rewriters, store, router, app = this.app, log = this.config.log } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setData({ injectors, middlewares, store }, { log });
            const rewriter = this.rewriter(rewriters, { log });
            app.use(rewriter);
            const defaults = this.defaults({}, { log });
            app.use(defaults);
            app.use(this.middlewares.globals);
            if (this.config.homePage) {
                const homePage = this.homePage({ log });
                app.use(this.config.base, homePage);
            }
            const resources = this.resources(db, { log, router });
            app.use(this.config.base, resources.router);
            app.use(this.pageNotFound);
            app.use(this.errorHandler);
            return yield this.startServer();
        });
    }
    defaults(options, { root = this.config.root, log = this.config.log, } = {}) {
        const logText = `${log}` === 'true' ? 'Defaults' : log;
        const spinner = !global.quiet && `${log}` !== 'false' && (0, ora_1.default)(`Loading ${logText}...`).start();
        if (!_.isEmpty(options))
            this.setConfig(options, { merge: true, root });
        spinner && spinner.stopAndPersist({ symbol: '✔', text: chalk_1.default.gray(`${logText} Loaded.`) });
        return (0, middlewares_1.Defaults)(this.config);
    }
    rewriter(rewriters, { root = this.config.root, router = express_1.default.Router(), log = this.config.log } = {}) {
        if (_.isEmpty(rewriters))
            return router;
        const logText = `${log}` === 'true' ? 'Rewriters' : log;
        const spinner = !global.quiet && `${log}` !== 'false' && (0, ora_1.default)(`Loading ${logText}...`).start();
        const newRewriters = (0, validators_1.getValidRewriters)(rewriters, { mockServer: this._getServerDetails(), root });
        const oldRewriters = this.getRewriters();
        Object.entries(newRewriters).forEach(([routePath, rewritePath]) => {
            if (this.rewriterRoutes.includes(routePath))
                return; // If routes are already added to rewriters then do nothing
            this.rewriterRoutes.push(routePath);
            oldRewriters[routePath] = rewritePath;
            router.use((0, express_urlrewrite_1.default)(routePath, rewritePath));
        });
        spinner && spinner.stopAndPersist({ symbol: '✔', text: chalk_1.default.gray(`${logText} Loaded.`) });
        return router;
    }
    resources(db, { middlewares, injectors, reverse = this.config.reverse, root = this.config.root, dbMode = this.config.dbMode, router = express_1.default.Router(), log = this.config.log, } = {}) {
        const create = (routePath, ...expressMiddlewares) => {
            const validRoute = (0, validators_1.getValidRoute)(routePath);
            const routeConfigSetters = new route_config_setters_1.default(validRoute, expressMiddlewares.flat(), dbMode);
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const parent = this;
            route_config_setters_1.default.prototype.done = function ({ log = parent.config.log } = {}) {
                parent.resources(this.db, { dbMode, injectors, log, middlewares, reverse, root, router });
                return this.db;
            };
            return routeConfigSetters;
        };
        if (_.isEmpty(db))
            return { create, router };
        const logText = `${log}` === 'true' ? 'Db Resources' : log;
        const spinner = !global.quiet && `${log}` !== 'false' && (0, ora_1.default)(`Loading ${logText}...`).start();
        const mockServer = this._getServerDetails();
        const validMiddlewares = middlewares ? (0, validators_1.getValidMiddlewares)(middlewares, { mockServer, root }) : this.middlewares;
        const validInjectors = injectors ? (0, validators_1.getValidInjectors)(injectors, { mockServer, root }) : this.injectors;
        const validDb = (0, validators_1.getValidDb)(db, { dbMode, injectors: validInjectors, mockServer, reverse, root });
        Object.entries(validDb).forEach(([routePath, routeConfig]) => __classPrivateFieldGet(this, _MockServer_createRoute, "f").call(this, routePath, routeConfig, router, validMiddlewares));
        spinner && spinner.stopAndPersist({ symbol: '✔', text: chalk_1.default.gray(`${logText} Loaded.`) });
        return { create, router };
    }
    startServer(port, host) {
        return __awaiter(this, void 0, void 0, function* () {
            if (_.isInteger(port) || !_.isEmpty(host)) {
                this.setConfig(Object.assign(Object.assign({}, this.config), { host: host || this.config.host, port: port !== null && port !== void 0 ? port : this.config.port }));
            }
            const { port: _port, host: _host, base: _base } = this.config;
            const spinner = (0, ora_1.default)('Starting Server...').start();
            // If server is already running then throw error
            if (this.server) {
                spinner.stop();
                this.port = undefined;
                this.address = undefined;
                this.listeningTo = undefined;
                const { port } = this.server.address();
                console.error(chalk_1.default.red('\nServer already listening to port : ') + chalk_1.default.yellow(port));
                throw new Error('Server already listening to port : ' + port);
            }
            try {
                this.server = yield new Promise((resolve, reject) => {
                    const server = this.app
                        .listen(_port, _host, () => __awaiter(this, void 0, void 0, function* () {
                        resolve(server);
                    }))
                        .on('error', (err) => {
                        reject(err);
                    });
                });
                if (!this.server)
                    throw new Error('Server Failed to Start.');
                (0, server_destroy_1.default)(this.server); // Enhance with a destroy function
                spinner.stop();
                process.stdout.write(chalk_1.default.green('\nMock Server Started!\n'));
                const serverAddress = (this.server.address() || {});
                this.port = serverAddress.port || this.config.port;
                this.address = serverAddress.address;
                this.listeningTo = `http://${_host}:${this.port}${_base}`;
                console.log('\n' + chalk_1.default.whiteBright('Access URLs:'));
                console.log(chalk_1.default.gray('-----------------------------------'));
                process.stdout.write('Localhost: ' + chalk_1.default.magenta(`http://${_host}:${this.port}${_base}`));
                console.log('\n      LAN: ' + chalk_1.default.magenta(`http://${this.address}:${this.port}${_base}`));
                console.log(chalk_1.default.gray('-----------------------------------'));
                console.log(chalk_1.default.blue('Press CTRL+C to stop'));
                process.stdout.write('\n' + chalk_1.default.gray('listening...') + '\n');
                console.log(`Number of routes: ${this.routes.length}\n`);
                return this.server;
            }
            catch (err) {
                spinner.stop();
                this.clearServerAddress();
                console.error(chalk_1.default.red('\nServer Failed to Start!'));
                console.error(err.message);
                throw err;
            }
        });
    }
    stopServer() {
        var _b;
        return __awaiter(this, void 0, void 0, function* () {
            const spinner = (0, ora_1.default)('Stopping Server...').start();
            // If there is no server to stop then throw error
            if (!this.server || !((_b = this.server) === null || _b === void 0 ? void 0 : _b.destroy)) {
                spinner && spinner.stop();
                console.error(chalk_1.default.red('\nNo Server to Stop'));
                throw new Error('No Server to Stop');
            }
            try {
                const isServerStopped = yield new Promise((resolve, reject) => {
                    var _b, _c;
                    (_c = (_b = this.server) === null || _b === void 0 ? void 0 : _b.destroy) === null || _c === void 0 ? void 0 : _c.call(_b, (err) => {
                        if (err) {
                            return reject(err);
                        }
                        resolve(true);
                    });
                });
                if (!isServerStopped)
                    throw new Error('Server Failed to Stop.');
                this.clearServerAddress();
                spinner.stop();
                process.stdout.write(chalk_1.default.green('Mock Server Stopped!'));
                return true;
            }
            catch (err) {
                spinner.stop();
                console.error(chalk_1.default.red('\nServer Failed to Stop!'));
                console.error(err.message);
                throw err;
            }
        });
    }
    resetServer() {
        this.clearServerAddress();
        this.createExpressApp();
        this.setDefaultDb();
        this.setDefaultMiddlewares();
        this.setDefaultInjectors();
        this.setDefaultStore();
        this.setDefaultRewriters();
    }
    resetDb(ids = [], routePaths = []) {
        if (!ids.length && !routePaths.length) {
            (0, utils_1.replaceObj)(this.getDb(), _.cloneDeep(this.initialDb));
            return this.db;
        }
        else {
            const _routePaths = ids.map((id) => Object.keys(this.initialDb).find((r) => this.initialDb[r].id == id)).filter(Boolean);
            const routePathToReset = [..._routePaths, ...routePaths];
            const restoredRoutes = routePathToReset.reduce((result, routePath) => {
                (0, utils_1.replaceObj)(this.getDb(routePath), _.cloneDeep(this.initialDb[routePath]));
                return Object.assign(Object.assign({}, result), { [routePath]: this.db[routePath] });
            }, {});
            return restoredRoutes;
        }
    }
    homePage({ log = this.config.log } = {}) {
        const spinner = !global.quiet && log && (0, ora_1.default)('Loading HomePage Resources...').start();
        const router = express_1.default.Router();
        const homePageDir = path_1.default.join(__dirname, '../public');
        router.use(express_1.default.static(homePageDir)); // Serve Mock Server HomePage
        const homePageRoutes = {
            '/_db/:id?': (req, res) => {
                switch (req.method) {
                    case 'POST':
                        return __classPrivateFieldGet(this, _MockServer_addDb, "f").call(this, req, res, router);
                    case 'PUT':
                        return __classPrivateFieldGet(this, _MockServer_updateRouteConfig, "f").call(this, req, res);
                    default:
                        return __classPrivateFieldGet(this, _MockServer_getDb, "f").call(this, req, res);
                }
            },
            '/_reset/:id?': (req, res) => {
                const ids = (0, utils_1.flatQuery)(req.params.id || req.query.id);
                const restoredRoutes = this.resetDb(ids);
                res.send(restoredRoutes);
            },
            '/_rewriters': (_req, res) => res.send(this.rewriters),
            '/_routes': (_req, res) => res.send(this.routes),
            '/_store': (_req, res) => res.send(this.store),
        };
        Object.entries(homePageRoutes).forEach(([routePath, routeConfig]) => {
            if (this.routes.includes(routePath))
                return;
            this.routes.push(routePath);
            router.use(routePath, routeConfig);
        });
        spinner && spinner.stopAndPersist({ symbol: '✔', text: chalk_1.default.gray('HomePage Resources Loaded.') });
        return router;
    }
}
exports.MockServer = MockServer;
_a = MockServer, _MockServer_createRoute = new WeakMap(), _MockServer_getMiddlewareList = new WeakMap(), _MockServer_addDb = new WeakMap(), _MockServer_getDb = new WeakMap(), _MockServer_updateRouteConfig = new WeakMap();
// eslint-disable-next-line no-use-before-define
_MockServer_mockServer = { value: void 0 };
MockServer.Create = (config) => {
    var _b;
    if (!__classPrivateFieldGet(MockServer, _a, "f", _MockServer_mockServer)) {
        __classPrivateFieldSet(MockServer, _a, new MockServer(config), "f", _MockServer_mockServer);
        return __classPrivateFieldGet(MockServer, _a, "f", _MockServer_mockServer);
    }
    else {
        (_b = __classPrivateFieldGet(MockServer, _a, "f", _MockServer_mockServer)) === null || _b === void 0 ? void 0 : _b.setConfig(config);
        return __classPrivateFieldGet(MockServer, _a, "f", _MockServer_mockServer);
    }
};
MockServer.Destroy = (mockServer) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    if (mockServer) {
        try {
            yield mockServer.stopServer();
        }
        catch (err) { }
        mockServer.resetServer();
        return undefined;
    }
    else {
        try {
            yield ((_b = __classPrivateFieldGet(MockServer, _a, "f", _MockServer_mockServer)) === null || _b === void 0 ? void 0 : _b.stopServer());
        }
        catch (err) { }
        (_c = __classPrivateFieldGet(MockServer, _a, "f", _MockServer_mockServer)) === null || _c === void 0 ? void 0 : _c.resetServer();
        __classPrivateFieldSet(MockServer, _a, undefined, "f", _MockServer_mockServer);
        return undefined;
    }
});
exports.default = MockServer;
