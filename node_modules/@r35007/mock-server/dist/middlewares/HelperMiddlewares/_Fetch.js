"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._Fetch = void 0;
const _ = __importStar(require("lodash"));
const utils_1 = require("../../utils");
const fetch_1 = require("../../utils/fetch");
const setFetchData = (locals, next) => {
    const routeConfig = locals.routeConfig;
    const { isError, response, statusCode, headers, isImage } = routeConfig.fetchData || {};
    locals.data = isError
        ? routeConfig.skipFetchError
            ? locals.data
            : isImage
                ? Buffer.from(response)
                : response
        : isImage
            ? Buffer.from(response)
            : response;
    locals.statusCode = isError ? (routeConfig.skipFetchError ? locals.statusCode : statusCode) : statusCode;
    locals.headers = isError ? (routeConfig.skipFetchError ? locals.headers : headers) : headers;
    next();
};
const getValidReq = (req, res, fetch) => {
    var _a;
    const locals = res.locals;
    const config = locals.config;
    const replacedPath = (0, utils_1.interpolate)({ config, req: _.cloneDeep(req) }, (_a = fetch.url) === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/'));
    const fetchEntries = Object.entries(fetch).map(([key, val]) => {
        return [key, (0, utils_1.interpolate)({ config, req: _.cloneDeep(req) }, val.replace(/\\/g, '/'))];
    });
    const request = Object.assign(Object.assign({}, _.fromPairs(fetchEntries)), { url: replacedPath });
    (0, utils_1.cleanObject)(request);
    return request;
};
const getUrlDetail = (req, res) => {
    var _a;
    const locals = res.locals;
    const fetch = locals.routeConfig.fetch;
    let request = {};
    if (_.isString(fetch)) {
        request = { url: fetch };
    }
    else if (_.isPlainObject(fetch)) {
        request = _.cloneDeep(fetch);
    }
    else {
        return;
    }
    if ((_a = request.url) === null || _a === void 0 ? void 0 : _a.startsWith('http')) {
        request = getValidReq(req, res, request);
        return { extension: '', isFile: false, request };
    }
    else {
        const parsedUrl = (0, fetch_1.parseUrl)(request.url, locals.config.root).replace(/\\/g, '/');
        const interpolatedUrl = (0, utils_1.interpolate)({ config: locals.config, req: _.cloneDeep(req) }, parsedUrl);
        const stats = (0, fetch_1.getStats)(interpolatedUrl);
        request.url = interpolatedUrl;
        return Object.assign({ request }, stats);
    }
};
const setRequestUrl = (req, res) => {
    var _a;
    const locals = res.locals;
    const routeConfig = locals.routeConfig;
    const fetchCount = parseInt(`${(_a = routeConfig.fetchCount) !== null && _a !== void 0 ? _a : ''}`);
    routeConfig.fetchCount = isNaN(fetchCount) ? 1 : fetchCount;
    const fetch = getUrlDetail(req, res);
    if (!fetch)
        return;
    routeConfig._request = fetch.request;
    routeConfig._isFile = fetch.isFile;
    routeConfig._extension = fetch.extension;
};
const _Fetch = (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    const locals = res.locals;
    const routeConfig = locals.routeConfig;
    // If mockFirst is true and mock data is defined then skip fetch
    if (routeConfig.mockFirst && routeConfig.mock !== undefined)
        return next();
    // If Data is already fetched and the fetch count is zero then send fetch response from fetchData
    if (routeConfig.fetchCount == 0 && !_.isEmpty(routeConfig.fetchData))
        return setFetchData(locals, next);
    // If it don't has any fetch url or request object then skip fetch
    if (_.isEmpty(routeConfig.fetch))
        return next();
    // generate valid request object from fetch attribute
    setRequestUrl(req, res);
    // if it doesn't has a valid request url then skip fetch
    if (!((_a = routeConfig._request) === null || _a === void 0 ? void 0 : _a.url))
        return next();
    // url starts with http then fetch data from url else skip fetch
    if (routeConfig._request.url.startsWith('http')) {
        routeConfig.fetchData = yield (0, fetch_1.getUrlData)(routeConfig._request);
    }
    // if url is a file and is one of .json, .jsonc, .har, .txt file then fetch file else skip fetch
    if (routeConfig._isFile && ['.json', '.jsonc', '.har', '.txt'].includes(routeConfig._extension || '')) {
        routeConfig.fetchData = yield (0, fetch_1.getFileData)(routeConfig._request.url);
    }
    // reduce fetch count
    routeConfig.fetchCount--;
    // delete route config store cache due to new fetch data.
    (_b = routeConfig.store) === null || _b === void 0 ? true : delete _b._IterateResponse;
    (_c = routeConfig.store) === null || _c === void 0 ? true : delete _c._IterateRoutes;
    (_d = routeConfig.store) === null || _d === void 0 ? true : delete _d._CrudOperation;
    // set fetch data to locals
    return setFetchData(locals, next);
});
exports._Fetch = _Fetch;
