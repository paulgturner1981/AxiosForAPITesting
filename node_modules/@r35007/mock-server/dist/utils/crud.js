"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const lodashIdMixin = __importStar(require("lodash-id"));
const nanoid_1 = require("nanoid");
const _1 = require(".");
const lodashId = _; // just to remove type when using mixin
lodashId.mixin(lodashIdMixin);
class default_1 {
}
exports.default = default_1;
default_1.search = (req, res, data) => {
    var _a;
    const config = ((_a = res.locals) === null || _a === void 0 ? void 0 : _a.config) || {};
    lodashId.id = config.id || 'id';
    const id = lodashId.id || config.id || 'id';
    let _data = _.cloneDeep(data);
    const query = req.query;
    const params = req.params;
    const ids = (0, _1.flatQuery)(params[id] || query[id]);
    const _sort = (0, _1.flatQuery)(query._sort);
    const _order = (0, _1.flatQuery)(query._order);
    const _start = (0, _1.flatQuery)(query._start, true)[0];
    const _end = (0, _1.flatQuery)(query._end, true)[0];
    const _limit = (0, _1.flatQuery)(query._limit, true)[0];
    const _page = (0, _1.flatQuery)(query._page, true)[0];
    const _first = (0, _1.flatQuery)(query._first)[0];
    const _last = (0, _1.flatQuery)(query._last)[0];
    const _text = (0, _1.flatQuery)(query._text);
    const q = (0, _1.flatQuery)(query.q);
    const isRange = _start || _end;
    delete query._sort;
    delete query._order;
    delete query._start;
    delete query._end;
    delete query._limit;
    delete query._page;
    delete query._text;
    delete query._first;
    delete query._last;
    delete query.q;
    // Filters By Id
    if (ids.length) {
        _data = ids.map((id) => lodashId.getById(_data, id)).filter(Boolean);
    }
    // Automatically delete query parameters that can't be found in database
    Object.keys(query).forEach((key) => {
        for (const i in _data) {
            const path = key.replace(/(_lte|_gte|_ne|_like)$/, '');
            if (_.has(_data[i], path) || key === 'callback' || key === '_')
                return;
        }
        delete query[key];
    });
    // Makes query.id=1,2 to query.id=[1,2]
    for (const key in query) {
        query[key] = (0, _1.flatQuery)(query[key]);
    }
    // Partial Text Search
    const searchTexts = [..._text, ...q].filter(Boolean);
    if (searchTexts.filter(Boolean).length) {
        _data = _data.filter((d) => searchTexts.some((_t) => {
            var _a, _b;
            return ((_a = _.values(d)
                .join(', ')) === null || _a === void 0 ? void 0 : _a.toLowerCase().indexOf((_b = `${_t || ''}`) === null || _b === void 0 ? void 0 : _b.toLowerCase())) >= 0;
        }));
    }
    // Attribute Filter
    _.toPairs(query).forEach(([key, val]) => {
        const _val = [].concat(val);
        const isDifferent = /_ne$/.test(key);
        const isRange = /_lte$/.test(key) || /_gte$/.test(key);
        const isLike = /_like$/.test(key);
        const path = key.replace(/(_lte|_gte|_ne|_like)$/, '');
        _data = _data.filter((obj) => {
            const objVal = _.get(obj, path);
            const valMatchList = _val.map((v) => {
                if (objVal === undefined || objVal === null) {
                    return undefined;
                }
                if (isRange) {
                    const isLowerThan = /_gte$/.test(key);
                    return isLowerThan ? v <= objVal : v >= objVal;
                }
                else if (isDifferent) {
                    return v != objVal.toString();
                }
                else if (isLike) {
                    return new RegExp(v, 'i').test(objVal.toString());
                }
                else {
                    return v == objVal.toString();
                }
            });
            const isMatched = valMatchList.reduce((a, b) => (isDifferent ? a && b : a || b));
            return isMatched;
        });
    });
    // Sort and Order
    _data = _.orderBy(_data, _sort, _order.map((o) => `${o || ''}`.toLowerCase()));
    // Ranging
    if (isRange) {
        const startIndex = _start !== null && _start !== void 0 ? _start : 0;
        const endIndex = _end !== null && _end !== void 0 ? _end : _data.length;
        _data = _data.slice(startIndex, endIndex) || [];
    }
    // Pagination
    if (_page !== undefined) {
        const chunks = _.chunk(_data, _limit !== null && _limit !== void 0 ? _limit : 10);
        const links = {};
        const fullURL = `http://${req.get('host')}${req.originalUrl}`;
        links.first = fullURL.replace(`_page=${_page}`, '_page=1');
        if (_page > 1)
            links.prev = fullURL.replace(`_page=${_page}`, `_page=${_page - 1}`);
        if (_page < chunks.length)
            links.next = fullURL.replace(`_page=${_page}`, `_page=${_page + 1}`);
        links.last = fullURL.replace(`_page=${_page}`, `_page=${chunks.length}`);
        res.links(links);
        _data = chunks[_page - 1] || [];
    }
    // Limit
    if (_limit !== undefined) {
        _data = _.take(_data, _limit) || [];
    }
    // First
    if (_first == 'true') {
        _data = _.head(_data);
    }
    // Last
    if (_last == 'true') {
        _data = _.last(_data);
    }
    // Set Headers
    if (_start || _end || _limit || _page) {
        res.setHeader('X-Total-Count', data.length);
        res.setHeader('Access-Control-Expose-Headers', `X-Total-Count${_page ? ', Link' : ''}`);
    }
    if (params[id] && _.isArray(_data) && (_data === null || _data === void 0 ? void 0 : _data.length) === 0)
        return {};
    if (params[id] && _.isArray(_data) && (_data === null || _data === void 0 ? void 0 : _data.length) === 1)
        return _data[0];
    return _data;
};
default_1.insert = (req, res, data) => {
    var _a;
    const config = ((_a = res.locals) === null || _a === void 0 ? void 0 : _a.config) || {};
    lodashId.id = config.id || 'id';
    const id = lodashId.id || config.id || 'id';
    lodashId.createId = (coll) => {
        if (_.isEmpty(coll)) {
            return 1;
        }
        else {
            let maxId = parseInt(lodashId.maxBy(coll, id)[id], 10); // Increment integer id or generate string id
            return !_.isNaN(maxId) ? ++maxId : (0, nanoid_1.nanoid)(7);
        }
    };
    const body = [].concat(req.body);
    if (_.isEmpty(body))
        return;
    body.forEach((b) => delete b.id);
    const insertedData = body.reduce((res, b) => res.concat(lodashId.insert(data, b)), []);
    return insertedData;
};
default_1.remove = (req, res, data) => {
    var _a;
    const config = ((_a = res.locals) === null || _a === void 0 ? void 0 : _a.config) || {};
    lodashId.id = config.id || 'id';
    const id = lodashId.id || config.id || 'id';
    if (req.params[id]) {
        return lodashId.removeById(data, req.params[id]);
    }
    else if (!_.isEmpty(req.query)) {
        return lodashId.removeWhere(data, req.query);
    }
    return {};
};
default_1.update = (req, res, data) => {
    var _a;
    const config = ((_a = res.locals) === null || _a === void 0 ? void 0 : _a.config) || {};
    lodashId.id = config.id || 'id';
    const id = lodashId.id || config.id || 'id';
    const body = [].concat(req.body)[0];
    if (_.isEmpty(body))
        return {};
    if (req.params[id]) {
        return lodashId.updateById(data, req.params[id], body);
    }
    else if (!_.isEmpty(req.query)) {
        return lodashId.updateWhere(data, req.query, body);
    }
    return {};
};
default_1.replace = (req, res, data) => {
    var _a;
    const config = ((_a = res.locals) === null || _a === void 0 ? void 0 : _a.config) || {};
    lodashId.id = config.id || 'id';
    const id = lodashId.id || config.id || 'id';
    const body = [].concat(req.body)[0];
    if (_.isEmpty(body))
        return {};
    if (req.params[id]) {
        return lodashId.replaceById(data, req.params[id], body);
    }
    else if (!_.isEmpty(req.query)) {
        const matchedIds = _.filter(data, req.query).map((d) => d[id]);
        return matchedIds.reduce((res, matchedId) => res.concat(lodashId.replaceById(data, matchedId, body)), []);
    }
    return {};
};
