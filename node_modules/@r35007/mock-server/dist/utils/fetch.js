"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireData = exports.parseUrl = exports.getUrlData = exports.getFileData = exports.getStats = exports.getFilesList = exports.getList = exports.getObject = exports.requireFile = exports.importJsonModuleSync = exports.importJsModuleSync = void 0;
const axios_1 = __importDefault(require("axios"));
const chalk_1 = __importDefault(require("chalk"));
const cjson = __importStar(require("comment-json"));
const fs = __importStar(require("fs"));
const fsProm = __importStar(require("fs/promises"));
const _ = __importStar(require("lodash"));
const path = __importStar(require("path"));
const _1 = require(".");
const importJsModuleSync = (modulePath) => {
    delete require.cache[require.resolve(modulePath)];
    return require(require.resolve(modulePath));
};
exports.importJsModuleSync = importJsModuleSync;
const importJsonModuleSync = (modulePath) => {
    try {
        const str = fs.readFileSync(modulePath, 'utf-8');
        return JSON.parse(str);
    }
    catch (err) {
        const str = fs.readFileSync(modulePath, 'utf-8');
        return cjson.parse(str, undefined, true);
    }
};
exports.importJsonModuleSync = importJsonModuleSync;
const requireFile = (directoryPath, { exclude = [], recursive = true, isList = false, onlyIndex = true, } = {}) => {
    const stats = (0, exports.getStats)(directoryPath);
    // If path doesn't exist then return
    if (!stats)
        return;
    // Get File data
    if (stats.isFile) {
        try {
            if (stats.extension.endsWith('js'))
                return (0, exports.importJsModuleSync)(stats.filePath);
            return (0, exports.importJsonModuleSync)(stats.filePath);
        }
        catch (error) {
            console.log(chalk_1.default.red(`Error reading ${stats.filePath}`));
            console.error(error.message);
            return;
        }
    }
    // If given path is a Directory then return accumulated data of all files in the directoryPath
    const filesList = (0, exports.getFilesList)(directoryPath, { exclude, onlyIndex, recursive });
    if (!filesList.length)
        return;
    if (filesList.length === 1)
        return (0, exports.requireFile)(filesList[0].filePath, { exclude, isList, onlyIndex, recursive });
    return isList ? (0, exports.getList)(filesList) : (0, exports.getObject)(filesList);
};
exports.requireFile = requireFile;
const getObject = (files) => {
    const obj = files.reduce((mock, file) => {
        const data = (0, exports.requireFile)(file.filePath);
        if (_.isEmpty(data) || !_.isPlainObject(data))
            return mock;
        return Object.assign(Object.assign({}, mock), data);
    }, {});
    return obj;
};
exports.getObject = getObject;
const getList = (files) => {
    const list = files.reduce((mock, file) => {
        const data = (0, exports.requireFile)(file.filePath);
        if (_.isEmpty(data) || !_.isArray(data))
            return mock;
        return [...mock, ...data];
    }, []);
    return list;
};
exports.getList = getList;
const getFilesList = (directoryPath, { exclude = [], recursive = true, onlyIndex = true } = {}) => {
    const stats = (0, exports.getStats)(directoryPath);
    if (!stats)
        return [];
    if (stats.isFile) {
        return [stats];
    }
    else if (stats.isDirectory && exclude.indexOf(directoryPath) < 0) {
        if (onlyIndex) {
            const indexPath = `${directoryPath}\\index.js`;
            const indexStats = (0, exports.getStats)(indexPath);
            if (indexStats)
                return [indexStats];
        }
        const files = fs.readdirSync(directoryPath);
        const filteredFiles = files.filter((file) => exclude.indexOf(file) < 0);
        const filesList = filteredFiles.reduce((res, file) => {
            if (recursive) {
                return res.concat((0, exports.getFilesList)(`${directoryPath}/${file}`, { exclude, onlyIndex, recursive }));
            }
            return res.concat((0, exports.getStats)(`${directoryPath}/${file}`) || []);
        }, []);
        return filesList;
    }
    return [];
};
exports.getFilesList = getFilesList;
const getStats = (directoryPath) => {
    if (!fs.existsSync(directoryPath))
        return;
    const stats = fs.statSync(directoryPath);
    const extension = path.extname(directoryPath);
    const fileName = path.basename(directoryPath, extension);
    return { extension, fileName, filePath: directoryPath, isDirectory: stats.isDirectory(), isFile: stats.isFile() };
};
exports.getStats = getStats;
const getFileData = (filePath) => __awaiter(void 0, void 0, void 0, function* () {
    let fetchData = { isError: false };
    const extension = path.extname(filePath);
    try {
        if (['.json', '.jsonc', '.har'].includes(extension)) {
            const str = yield fsProm.readFile(filePath, { encoding: 'utf-8' });
            fetchData.response = _.isEmpty(str) ? {} : (0, _1.getParsedJSON)(str);
        }
        else if (extension === '.txt') {
            fetchData.response = yield fsProm.readFile(filePath, { encoding: 'utf-8' });
        }
        else {
            const str = yield fsProm.readFile(filePath, { encoding: 'utf-8' });
            fetchData.response = _.isEmpty(str) ? {} : (0, _1.getParsedJSON)(str);
        }
    }
    catch (err) {
        console.error(chalk_1.default.red(err.message));
        fetchData = {
            isError: true,
            message: err.message,
            response: {},
            stack: err.stack,
        };
    }
    return fetchData;
});
exports.getFileData = getFileData;
const getUrlData = (request) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let fetchData = { isError: false };
    try {
        let response;
        if ((_a = request.url) === null || _a === void 0 ? void 0 : _a.match(/\.(jpeg|jpg|gif|png)$/gi)) {
            response = yield axios_1.default.get(request.url, { responseType: 'arraybuffer' });
        }
        else {
            response = yield (0, axios_1.default)(request);
        }
        const isImage = ((_c = (_b = response.headers['content-type']) === null || _b === void 0 ? void 0 : _b.match(/image\/(jpeg|jpg|gif|png)$/gi)) === null || _c === void 0 ? void 0 : _c.length) > 0;
        const headers = Object.assign({}, (response.headers || {}));
        delete headers['transfer-encoding'];
        delete headers['content-length'];
        fetchData = {
            headers,
            isError: false,
            isImage,
            response: response.data,
            statusCode: response.status,
        };
    }
    catch (err) {
        console.error(chalk_1.default.red(err.message));
        fetchData = {
            headers: (_d = err.response) === null || _d === void 0 ? void 0 : _d.headers,
            isError: true,
            message: err.message || ((_e = err.response) === null || _e === void 0 ? void 0 : _e.statusText) || 'Internal Server Error',
            response: (_g = (_f = err.response) === null || _f === void 0 ? void 0 : _f.data) !== null && _g !== void 0 ? _g : {},
            stack: err.stack,
            statusCode: (_h = err.response) === null || _h === void 0 ? void 0 : _h.status,
        };
    }
    return fetchData;
});
exports.getUrlData = getUrlData;
const parseUrl = (relativeUrl, root = process.cwd()) => {
    if (!relativeUrl || typeof relativeUrl !== 'string' || !(relativeUrl === null || relativeUrl === void 0 ? void 0 : relativeUrl.trim().length))
        return '';
    if (relativeUrl.startsWith('http'))
        return relativeUrl;
    const parsedUrl = decodeURIComponent(path.resolve(root, relativeUrl));
    return parsedUrl;
};
exports.parseUrl = parseUrl;
const requireData = (data, { root = process.cwd(), isList = false, onlyIndex = true, recursive = true, exclude = [], } = {}) => {
    if (!data)
        return;
    if (_.isFunction(data))
        return data;
    if (_.isString(data)) {
        const parsedUrl = (0, exports.parseUrl)(data, root);
        if (data.length && !fs.existsSync(parsedUrl)) {
            process.stdout.write('\n' + chalk_1.default.red('Invalid Path: ') + chalk_1.default.yellow(parsedUrl) + '\n');
            return {};
        }
        const requiredFile = (0, exports.requireFile)(parsedUrl, { exclude, isList, onlyIndex, recursive });
        return (0, exports.requireData)(requiredFile, { exclude, isList, onlyIndex, recursive, root });
    }
    if (isList && _.isArray(data))
        return _.cloneDeep(data);
    if (!isList && _.isPlainObject(data))
        return _.cloneDeep(data);
};
exports.requireData = requireData;
