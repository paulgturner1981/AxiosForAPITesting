"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixed = exports.interpolate = exports.toBase64 = exports.extractDbFromKibana = exports.extractDbFromHAR = exports.getParsedJSON = exports.getURLPathName = exports.isCollection = exports.cleanRouteConfig = exports.getCleanDb = exports.cleanObject = exports.replaceObj = exports.flatQuery = exports.getMatchedRoutesList = exports.getInjectedDb = exports.normalizeDb = void 0;
const cjson = __importStar(require("comment-json"));
const _ = __importStar(require("lodash"));
const nanoid_1 = require("nanoid");
const path_to_regexp_1 = require("path-to-regexp");
const Defaults = __importStar(require("../defaults"));
const validators_1 = require("./validators");
// { "/route1,/route2": { ... } } -> { "/route1": {...}, "/route2": { ... } }
const normalizeDb = (object, dbMode = Defaults.Config.dbMode) => {
    const normalizedDbEntries = Object.entries(object)
        .map(([routePath, routeConfig]) => {
        return routePath.split(',').map((route) => {
            const validRoute = (0, validators_1.getValidRoute)(route);
            return [validRoute, (0, validators_1.getValidRouteConfig)(validRoute, routeConfig, dbMode)];
        });
    })
        .flat();
    return _.fromPairs(normalizedDbEntries);
};
exports.normalizeDb = normalizeDb;
// Combines Injector Configs with the Db Configs
const getInjectedDb = (db, injectors) => {
    const injectedDb = {};
    const injectConfig = (route, currInjectorConfig) => {
        var _a;
        const prevDbConfig = (db[route] || {});
        const prevInjectorConfig = (injectedDb[route] || {});
        const prevMiddlewares = ((_a = prevInjectorConfig.middlewares) === null || _a === void 0 ? void 0 : _a.length) ? prevInjectorConfig.middlewares : prevDbConfig.middlewares;
        const currMiddlewares = currInjectorConfig.middlewares;
        injectedDb[route] = Object.assign(Object.assign(Object.assign(Object.assign({}, currInjectorConfig), prevDbConfig), prevInjectorConfig), (currInjectorConfig.override ? currInjectorConfig : {}));
        const mergedMiddlewares = mergeMiddlewares(prevMiddlewares, currMiddlewares);
        injectedDb[route].middlewares = mergedMiddlewares;
        if (!(mergedMiddlewares === null || mergedMiddlewares === void 0 ? void 0 : mergedMiddlewares.length)) {
            delete injectedDb[route].middlewares;
        }
        delete injectedDb[route].routes;
        delete injectedDb[route].override;
        delete injectedDb[route].exact;
    };
    injectors.forEach((currInjectorConfig) => {
        const matchedRoutes = _.flatten(currInjectorConfig.routes.map((route) => (0, exports.getMatchedRoutesList)(route, db, currInjectorConfig.exact)));
        matchedRoutes.forEach((route) => injectConfig(route, currInjectorConfig));
    });
    return _.cloneDeep(Object.assign(Object.assign({}, db), injectedDb));
};
exports.getInjectedDb = getInjectedDb;
const getMatchedRoutesList = (routeToMatch, db, exact = false) => {
    const matched = (0, path_to_regexp_1.match)(routeToMatch);
    return exact ? Object.keys(db).filter((r) => r === routeToMatch) : Object.keys(db).filter((r) => matched(r));
};
exports.getMatchedRoutesList = getMatchedRoutesList;
const flatQuery = (data, isNumber) => {
    const filterNumbers = (val) => !isNaN(val) && val !== undefined && val !== null;
    const result = _.flattenDeep([]
        .concat(data)
        .filter(Boolean)
        .map((s) => s.split(',')))
        .map((s) => (isNumber ? parseInt(s) : s))
        .filter(isNumber ? filterNumbers : Boolean);
    return result;
};
exports.flatQuery = flatQuery;
const replaceObj = (oldObj, newObj) => {
    for (const key in oldObj) {
        delete oldObj[key]; // clearing all existing Route Config values.
    }
    for (const key in newObj) {
        oldObj[key] = newObj[key]; // adding updated Route Config values
    }
};
exports.replaceObj = replaceObj;
const cleanObject = (obj) => {
    try {
        for (const key in obj) {
            if (obj[key] === null || obj[key] === undefined)
                delete obj[key]; // delete if null or undefined
            if (obj[key] !== undefined && !_.toString(obj[key]).trim())
                delete obj[key]; // delete if empty string
            if (obj[key] !== undefined && _.toString(obj[key]) === 'NaN')
                delete obj[key]; // delete if NaN
            if (obj[key] !== undefined && typeof obj[key] === 'object' && _.isEmpty(obj[key]))
                delete obj[key]; // delete If empty object
            if (obj[key] !== undefined && !_.isEmpty(obj[key]) && _.isPlainObject(obj[key]))
                (0, exports.cleanObject)(obj[key]); // cleanObject if the value is object
        }
    }
    catch (err) { }
};
exports.cleanObject = cleanObject;
const getCleanDb = (db, dbMode = 'mock') => {
    for (const routePath in db) {
        db[routePath] = (0, exports.cleanRouteConfig)(db[routePath], dbMode);
    }
    return db;
};
exports.getCleanDb = getCleanDb;
// Removes id, _config ( if only mock is available ) and all other empty values in route configs
const cleanRouteConfig = (routeConfig, dbMode = 'mock') => {
    if (!routeConfig._config)
        return routeConfig; // clean routeConfig only if _config is set to true
    const userTypeRouteConfig = routeConfig;
    delete userTypeRouteConfig.id;
    // Remove all empty list and objects
    (0, exports.cleanObject)(userTypeRouteConfig);
    const routeConfigKeys = Object.keys(userTypeRouteConfig);
    if (!routeConfigKeys.length)
        return userTypeRouteConfig;
    if (!routeConfigKeys.includes('_config'))
        return userTypeRouteConfig;
    if (routeConfigKeys.length === 1)
        return {};
    if (routeConfigKeys.length > 2)
        return userTypeRouteConfig;
    // If routeConfigKeys.length === 2 && routeConfigKeys.includes("_config")
    if (dbMode === 'multi') {
        if (routeConfigKeys.includes('fetch') && _.isString(userTypeRouteConfig.fetch))
            return userTypeRouteConfig.fetch;
        if (routeConfigKeys.includes('fetch') && !_.isString(userTypeRouteConfig.fetch))
            return userTypeRouteConfig;
        if (routeConfigKeys.includes('mock') && _.isString(userTypeRouteConfig.mock))
            return userTypeRouteConfig;
        if (routeConfigKeys.includes('mock') && !_.isString(userTypeRouteConfig.mock))
            return userTypeRouteConfig.mock;
        return userTypeRouteConfig;
    }
    else {
        if (dbMode === 'mock' && routeConfigKeys.includes('mock'))
            return userTypeRouteConfig.mock;
        if (dbMode === 'fetch' && routeConfigKeys.includes('fetch'))
            return userTypeRouteConfig.fetch;
        return userTypeRouteConfig;
    }
};
exports.cleanRouteConfig = cleanRouteConfig;
const isCollection = (arr) => {
    if (!_.isArray(arr))
        return false;
    if (!arr.every((i) => _.isPlainObject(i)))
        return false;
    return true;
};
exports.isCollection = isCollection;
const getURLPathName = (url = '') => {
    var _a;
    try {
        return ((_a = new URL(url)) === null || _a === void 0 ? void 0 : _a.pathname) || '';
    }
    catch (error) {
        return '';
    }
};
exports.getURLPathName = getURLPathName;
const getParsedJSON = (json = '') => {
    try {
        return cjson.parse(json, undefined, true);
    }
    catch (error) {
        return json;
    }
};
exports.getParsedJSON = getParsedJSON;
const getDbFromHarEntries = (entries, harEntryCallback, iterateDuplicateRoutes = false) => {
    const generatedDb = {};
    entries.forEach((entry) => {
        var _a, _b, _c;
        const route = (0, exports.getURLPathName)((_a = entry === null || entry === void 0 ? void 0 : entry.request) === null || _a === void 0 ? void 0 : _a.url);
        const mock = (0, exports.getParsedJSON)((_c = (_b = entry === null || entry === void 0 ? void 0 : entry.response) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.text);
        if (!route)
            return;
        let routePath = (0, validators_1.getValidRoute)(route || '');
        let routeConfig = {
            _config: true,
            mock,
        };
        if (_.isFunction(harEntryCallback)) {
            const routes = harEntryCallback(entry, routePath, routeConfig) || {};
            [routePath, routeConfig] = Object.entries(routes)[0] || [];
            routeConfig = (0, validators_1.getValidRouteConfig)(routePath, routeConfig, Defaults.Config.dbMode);
        }
        routePath && routeConfig && setRouteRedirects(generatedDb, routePath, routeConfig, iterateDuplicateRoutes);
    });
    return generatedDb;
};
const getDbFromKibanaHits = (hits, kibanaHitCallback, iterateDuplicateRoutes = false) => {
    const generatedDb = {};
    hits.forEach((hit) => {
        var _a, _b;
        const route = (0, exports.getURLPathName)((_a = hit === null || hit === void 0 ? void 0 : hit._source) === null || _a === void 0 ? void 0 : _a.requestURI);
        const mock = (0, exports.getParsedJSON)((_b = hit === null || hit === void 0 ? void 0 : hit._source) === null || _b === void 0 ? void 0 : _b.response);
        if (!route)
            return;
        let routePath = (0, validators_1.getValidRoute)(route || '');
        let routeConfig = {
            _config: true,
            mock,
        };
        if (_.isFunction(kibanaHitCallback)) {
            const routes = kibanaHitCallback(hit, routePath, routeConfig) || {};
            [routePath, routeConfig] = Object.entries(routes)[0] || [];
            routeConfig = (0, validators_1.getValidRouteConfig)(routePath, routeConfig, Defaults.Config.dbMode);
        }
        routePath && routeConfig && setRouteRedirects(generatedDb, routePath, routeConfig, iterateDuplicateRoutes);
    });
    return generatedDb;
};
const setRouteRedirects = (db, routePath, currentRouteConfig, iterateDuplicateRoutes = false) => {
    var _a;
    if (iterateDuplicateRoutes && db[routePath]) {
        const existingConfig = db[routePath];
        if (((_a = db[routePath].middlewares) === null || _a === void 0 ? void 0 : _a[0]) !== '_IterateRoutes') {
            const iterateRoute1 = (0, validators_1.getValidRoute)(routePath + '/' + (0, nanoid_1.nanoid)(5));
            const iterateRoute2 = (0, validators_1.getValidRoute)(routePath + '/' + (0, nanoid_1.nanoid)(5));
            db[routePath] = {
                _config: true,
                middlewares: ['_IterateRoutes'],
                mock: [iterateRoute1, iterateRoute2],
            };
            db[iterateRoute1] = existingConfig;
            db[iterateRoute2] = currentRouteConfig;
        }
        else {
            const iterateRoute = (0, validators_1.getValidRoute)(routePath + '/' + (0, nanoid_1.nanoid)(5));
            db[routePath].mock.push(iterateRoute);
            db[iterateRoute] = currentRouteConfig;
        }
    }
    else {
        db[routePath] = currentRouteConfig;
    }
};
const mergeMiddlewares = (prevMiddlewares, currMiddlewares) => {
    if (!currMiddlewares)
        return prevMiddlewares;
    const mergedMiddlewares = currMiddlewares.reduce((result, middleware) => middleware === '...' ? [...result, ...(prevMiddlewares || [])] : [...result, middleware], []);
    return [...new Set(mergedMiddlewares)];
};
const extractDbFromHAR = (har, harEntryCallback, harDbCallback, iterateDuplicateRoutes = false) => {
    var _a;
    try {
        const entries = (_a = har === null || har === void 0 ? void 0 : har.log) === null || _a === void 0 ? void 0 : _a.entries;
        const isHAR = (entries === null || entries === void 0 ? void 0 : entries.length) > 0;
        if (!isHAR)
            return;
        const dbFromHar = getDbFromHarEntries(entries, harEntryCallback, iterateDuplicateRoutes);
        return (harDbCallback === null || harDbCallback === void 0 ? void 0 : harDbCallback(har, dbFromHar)) || dbFromHar;
    }
    catch (err) {
        console.error(err.message);
    }
};
exports.extractDbFromHAR = extractDbFromHAR;
const extractDbFromKibana = (kibana, kibanaHitsCallback, KibanaDbCallback, iterateDuplicateRoutes = false) => {
    var _a, _b;
    try {
        const hits = (_b = (_a = kibana === null || kibana === void 0 ? void 0 : kibana.rawResponse) === null || _a === void 0 ? void 0 : _a.hits) === null || _b === void 0 ? void 0 : _b.hits;
        const isKibana = (hits === null || hits === void 0 ? void 0 : hits.length) > 0;
        if (!isKibana)
            return;
        const dbFromHits = getDbFromKibanaHits(hits, kibanaHitsCallback, iterateDuplicateRoutes);
        return (KibanaDbCallback === null || KibanaDbCallback === void 0 ? void 0 : KibanaDbCallback(kibana, dbFromHits)) || dbFromHits;
    }
    catch (err) {
        console.error(err.message);
    }
};
exports.extractDbFromKibana = extractDbFromKibana;
const toBase64 = (value = '') => {
    try {
        return Buffer.from(value).toString('base64');
    }
    catch (_a) {
        return value;
    }
};
exports.toBase64 = toBase64;
// Helps to convert template literal strings to applied values.
// Ex : Object = { config: { host: "localhost", port: 3000 } } , format = "${config.host}:${config.port}" -> "localhost:3000"
const interpolate = (object, format = '') => {
    try {
        const keys = _.keys(object);
        const values = _.values(object);
        // eslint-disable-next-line no-new-func
        return new Function(...keys, `return \`${format}\`;`)(...values);
    }
    catch (error) {
        console.error(error.message);
        return format;
    }
};
exports.interpolate = interpolate;
const prefixed = (prefix, object) => {
    const entries = Object.entries(object).map(([route, routeConfig]) => {
        const prefixedRoute = (0, validators_1.getValidRoute)(`${(0, validators_1.getValidRoute)(prefix)}/${(0, validators_1.getValidRoute)(route)}`);
        return [prefixedRoute, routeConfig];
    });
    return _.fromPairs(entries);
};
exports.prefixed = prefixed;
