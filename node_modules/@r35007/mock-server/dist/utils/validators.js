"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidRoute = exports.getValidInjectorConfig = exports.getValidRouteConfig = exports.getValidDb = exports.getValidRewriters = exports.getValidStore = exports.getValidInjectors = exports.getValidMiddlewares = exports.getValidConfig = void 0;
const ip_1 = __importDefault(require("ip"));
const _ = __importStar(require("lodash"));
const _1 = require(".");
const Defaults = __importStar(require("../defaults"));
const fetch_1 = require("./fetch");
const getValidConfig = (config, { root = Defaults.Config.root, mockServer } = {}) => {
    var _a;
    const requiredData = (0, fetch_1.requireData)(config, { root });
    const userConfig = _.isFunction(requiredData) ? requiredData(mockServer) : requiredData;
    if (_.isEmpty(userConfig) || !_.isPlainObject(userConfig))
        return _.cloneDeep(Defaults.Config);
    const parsedRoot = (0, fetch_1.parseUrl)(userConfig.root, Defaults.Config.root);
    const _root = ((_a = (0, fetch_1.getStats)(parsedRoot)) === null || _a === void 0 ? void 0 : _a.isDirectory) ? parsedRoot : Defaults.Config.root;
    const validConfig = Object.assign(Object.assign({}, userConfig), { base: userConfig.base && (0, exports.getValidRoute)(userConfig.base) !== '/' ? (0, exports.getValidRoute)(userConfig.base) : undefined, dbMode: ['multi', 'fetch', 'mock', 'config'].includes(userConfig.dbMode || '') ? userConfig.dbMode : undefined, host: typeof userConfig.host !== 'undefined'
            ? _.isString(userConfig.host)
                ? userConfig.host.trim() === ''
                    ? ip_1.default.address()
                    : userConfig.host
                : undefined
            : undefined, id: !_.isEmpty(userConfig.id) && _.isString(userConfig.id) ? userConfig.id : undefined, port: !_.isNaN(parseInt(userConfig.port)) ? parseInt(userConfig.port) : undefined, root: userConfig.root ? _root : undefined, static: typeof userConfig.static !== 'undefined' ? (0, fetch_1.parseUrl)(userConfig.static, _root) : undefined });
    return _.omitBy(validConfig, _.isUndefined);
};
exports.getValidConfig = getValidConfig;
const getValidMiddlewares = (middlewares, { root = Defaults.Config.root, mockServer } = {}) => {
    const requiredData = (0, fetch_1.requireData)(middlewares, { root });
    const userMiddlewares = _.isFunction(requiredData) ? requiredData(mockServer) : requiredData;
    if (_.isEmpty(userMiddlewares) || !_.isPlainObject(userMiddlewares))
        return _.cloneDeep(Defaults.Middlewares);
    const validMiddlewares = {};
    const middlewareNames = Object.keys(userMiddlewares);
    for (const name of middlewareNames) {
        if (_.isFunction(userMiddlewares[name])) {
            validMiddlewares[name] = userMiddlewares[name];
        }
        else if (_.isArray(userMiddlewares[name])) {
            const validMiddlewaresList = userMiddlewares[name].filter((m) => _.isFunction(m));
            validMiddlewaresList.length && (validMiddlewares[name] = validMiddlewaresList);
        }
    }
    if (_.isFunction(validMiddlewares.globals)) {
        validMiddlewares.globals = [validMiddlewares.globals];
    }
    if (_.isEmpty(validMiddlewares.globals)) {
        validMiddlewares.globals = [
            (_rq, _res, next) => {
                next();
            },
        ];
    }
    return Object.assign(Object.assign({}, Defaults.Middlewares), validMiddlewares);
};
exports.getValidMiddlewares = getValidMiddlewares;
const getValidInjectors = (injectors, { root = Defaults.Config.root, mockServer } = {}) => {
    const requiredData = (0, fetch_1.requireData)(injectors, { isList: true, root });
    const userInjectors = _.isFunction(requiredData) ? requiredData(mockServer) : requiredData;
    if (_.isEmpty(userInjectors) || !_.isArray(userInjectors) || !(0, _1.isCollection)(userInjectors))
        return _.cloneDeep(Defaults.Injectors);
    const validInjectors = userInjectors.map(exports.getValidInjectorConfig);
    return validInjectors;
};
exports.getValidInjectors = getValidInjectors;
const getValidStore = (store, { root = Defaults.Config.root, mockServer } = {}) => {
    const requiredData = (0, fetch_1.requireData)(store, { root });
    const userStore = _.isFunction(requiredData) ? requiredData(mockServer) : requiredData;
    if (_.isEmpty(userStore) || !_.isPlainObject(userStore))
        return _.cloneDeep(Defaults.Store);
    return userStore;
};
exports.getValidStore = getValidStore;
const getValidRewriters = (rewriters, { root = Defaults.Config.root, mockServer } = {}) => {
    const requiredData = (0, fetch_1.requireData)(rewriters, { root });
    const userRewriters = _.isFunction(requiredData) ? requiredData(mockServer) : requiredData;
    if (_.isEmpty(userRewriters) || !_.isPlainObject(userRewriters))
        return _.cloneDeep(Defaults.Rewriters);
    return userRewriters;
};
exports.getValidRewriters = getValidRewriters;
const getValidDb = (data, { mockServer, injectors = Defaults.Injectors, root = Defaults.Config.root, reverse = Defaults.Config.reverse, dbMode = Defaults.Config.dbMode, } = {}) => {
    const requiredData = (0, fetch_1.requireData)(data, { root });
    const userData = _.isFunction(requiredData) ? requiredData(mockServer) : requiredData;
    if (_.isEmpty(userData) || !_.isPlainObject(userData))
        return _.cloneDeep(Defaults.Db);
    const normalizedDb = (0, _1.normalizeDb)(userData, dbMode);
    const validInjectors = (0, exports.getValidInjectors)(injectors, { mockServer, root });
    const injectedDb = (0, _1.getInjectedDb)(normalizedDb, validInjectors);
    const validDb = reverse ? _.fromPairs(Object.entries(injectedDb).reverse()) : injectedDb;
    return validDb;
};
exports.getValidDb = getValidDb;
const getValidRouteConfig = (route, routeConfig, dbMode = Defaults.Config.dbMode) => {
    // If the given value is a function or array of function then directly use that function without helper middlewares
    if (_.isFunction(routeConfig) || (_.isArray(routeConfig) && routeConfig.every(_.isFunction)))
        return { _config: true, directUse: true, id: (0, _1.toBase64)(route), middlewares: [routeConfig] };
    // if db mode is config then strictly expect an config object
    if (dbMode === 'config' && _.isPlainObject(routeConfig))
        return Object.assign(Object.assign({ id: (0, _1.toBase64)(route), mock: {} }, routeConfig), { _config: true });
    if (dbMode === 'config' && !_.isPlainObject(routeConfig))
        return { _config: true, id: (0, _1.toBase64)(route), mock: {} };
    // If its not already a config object then define a config based on db mode
    if (!_.isPlainObject(routeConfig) || !routeConfig._config) {
        if (dbMode === 'multi' && _.isString(routeConfig))
            return { _config: true, fetch: routeConfig, id: (0, _1.toBase64)(route) };
        if (dbMode === 'multi' && !_.isString(routeConfig))
            return { _config: true, id: (0, _1.toBase64)(route), mock: routeConfig };
        if (dbMode === 'mock')
            return { _config: true, id: (0, _1.toBase64)(route), mock: routeConfig };
        if (dbMode === 'fetch')
            return { _config: true, fetch: routeConfig, id: (0, _1.toBase64)(route) };
    }
    routeConfig.id = `${routeConfig.id || ''}` || (0, _1.toBase64)(route);
    if (routeConfig.middlewares) {
        routeConfig.middlewares = [].concat(routeConfig.middlewares || []);
        if (!routeConfig.middlewares.length)
            delete routeConfig.middlewares;
    }
    return routeConfig;
};
exports.getValidRouteConfig = getValidRouteConfig;
const getValidInjectorConfig = (routeConfig) => {
    routeConfig.routes = [].concat(routeConfig.routes).map(exports.getValidRoute);
    if (routeConfig.middlewares) {
        routeConfig.middlewares = [].concat(routeConfig.middlewares || []);
    }
    return routeConfig;
};
exports.getValidInjectorConfig = getValidInjectorConfig;
const getValidRoute = (route) => {
    const trimmedRoute = '/' +
        route
            .split('/')
            .filter((x) => x.trim())
            .map((x) => x.trim())
            .join('/');
    return trimmedRoute;
};
exports.getValidRoute = getValidRoute;
